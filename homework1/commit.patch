diff --git a/CMakeLists.txt b/CMakeLists.txt
index f78ddd2c..b2b6f224 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -149,4 +149,4 @@ set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin/")
 
 add_subdirectory(base)
 add_subdirectory(homework)
-# add_subdirectory(examples)
+add_subdirectory(examples)
diff --git a/data/homework/shaders/glsl/homework1/mesh.vert b/data/homework/shaders/glsl/homework1/mesh.vert
index e2da4ece..14ad1813 100644
--- a/data/homework/shaders/glsl/homework1/mesh.vert
+++ b/data/homework/shaders/glsl/homework1/mesh.vert
@@ -4,6 +4,8 @@ layout (location = 0) in vec3 inPos;
 layout (location = 1) in vec3 inNormal;
 layout (location = 2) in vec2 inUV;
 layout (location = 3) in vec3 inColor;
+layout (location = 4) in vec4 inJointIndices;
+layout (location = 5) in vec4 inJointWeights;
 
 layout (set = 0, binding = 0) uniform UBOScene
 {
@@ -17,6 +19,10 @@ layout(push_constant) uniform PushConsts {
 	mat4 model;
 } primitive;
 
+//layout(std430, set = 1, binding = 0) readonly buffer JointMatrices {
+//	mat4 jointMatrices[];
+//};
+
 layout (location = 0) out vec3 outNormal;
 layout (location = 1) out vec3 outColor;
 layout (location = 2) out vec2 outUV;
@@ -28,6 +34,15 @@ void main()
 	outNormal = inNormal;
 	outColor = inColor;
 	outUV = inUV;
+
+	// Calculate skinned matrix from weights and joint indices of the current vertex
+	//mat4 skinMat = 
+		inJointWeights.x * jointMatrices[int(inJointIndices.x)] +
+		inJointWeights.y * jointMatrices[int(inJointIndices.y)] +
+		inJointWeights.z * jointMatrices[int(inJointIndices.z)] +
+		inJointWeights.w * jointMatrices[int(inJointIndices.w)];
+
+	//gl_Position = uboScene.projection * uboScene.view * primitive.model * vec4(inPos.xyz, 1.0);
 	gl_Position = uboScene.projection * uboScene.view * primitive.model * vec4(inPos.xyz, 1.0);
 	
 	vec4 pos = uboScene.view * vec4(inPos, 1.0);
diff --git a/examples/gltfskinning/gltfskinning.cpp b/examples/gltfskinning/gltfskinning.cpp
index f019395e..1ebf9723 100644
--- a/examples/gltfskinning/gltfskinning.cpp
+++ b/examples/gltfskinning/gltfskinning.cpp
@@ -967,7 +967,8 @@ void VulkanExample::updateUniformBuffers()
 
 void VulkanExample::loadAssets()
 {
-	loadglTFFile(getAssetPath() + "models/CesiumMan/glTF/CesiumMan.gltf");
+	//loadglTFFile(getAssetPath() + "models/CesiumMan/glTF/CesiumMan.gltf");
+	loadglTFFile(getAssetPath() + "buster_drone/busterDrone.gltf");
 }
 
 void VulkanExample::prepare()
diff --git a/homework/homework1/homework1.cpp b/homework/homework1/homework1.cpp
index 33f9e191..b55a57b5 100644
--- a/homework/homework1/homework1.cpp
+++ b/homework/homework1/homework1.cpp
@@ -39,11 +39,20 @@ public:
 	VkQueue copyQueue;
 
 	// The vertex layout for the samples' model
-	struct Vertex {
+	/*struct Vertex {
 		glm::vec3 pos;
 		glm::vec3 normal;
 		glm::vec2 uv;
 		glm::vec3 color;
+	};*/
+	struct Vertex
+	{
+		glm::vec3 pos;
+		glm::vec3 normal;
+		glm::vec2 uv;
+		glm::vec3 color;
+		glm::vec4 jointIndices;
+		glm::vec4 jointWeights;
 	};
 
 	// Single vertex buffer for all primitives
@@ -76,7 +85,7 @@ public:
 	};
 
 	// A node represents an object in the glTF scene graph
-	struct Node {
+	/*struct Node {
 		Node* parent;
 		std::vector<Node*> children;
 		Mesh mesh;
@@ -86,6 +95,63 @@ public:
 				delete child;
 			}
 		}
+	};*/
+	struct Node
+	{
+		Node* parent;
+		uint32_t            index;
+		std::vector<Node*> children;
+		Mesh                mesh;
+		glm::vec3           translation{};
+		glm::vec3           scale{ 1.0f };
+		glm::quat           rotation{};
+		int32_t             skin = -1;
+		glm::mat4           matrix;
+		glm::mat4           getLocalMatrix() {
+			return glm::translate(glm::mat4(1.0f), translation) * glm::mat4(rotation) * glm::scale(glm::mat4(1.0f), scale) * matrix;
+		}
+	};
+	
+	/*
+		Skin structure
+	*/
+
+	struct Skin
+	{
+		std::string            name;
+		Node* skeletonRoot = nullptr;
+		std::vector<glm::mat4> inverseBindMatrices;
+		std::vector<Node*>    joints;
+		vks::Buffer            ssbo;
+		VkDescriptorSet        descriptorSet;
+	};
+
+	/*
+		Animation related structures
+	*/
+
+	struct AnimationSampler
+	{
+		std::string            interpolation;
+		std::vector<float>     inputs;
+		std::vector<glm::vec4> outputsVec4;
+	};
+
+	struct AnimationChannel
+	{
+		std::string path;
+		Node* node;
+		uint32_t    samplerIndex;
+	};
+
+	struct Animation
+	{
+		std::string                   name;
+		std::vector<AnimationSampler> samplers;
+		std::vector<AnimationChannel> channels;
+		float                         start = std::numeric_limits<float>::max();
+		float                         end = std::numeric_limits<float>::min();
+		float                         currentTime = 0.0f;
 	};
 
 	// A glTF material stores information in e.g. the texture that is attached to it and colors
@@ -115,6 +181,10 @@ public:
 	std::vector<Texture> textures;
 	std::vector<Material> materials;
 	std::vector<Node*> nodes;
+	std::vector<Skin>      skins;
+	std::vector<Animation> animations;
+
+	uint32_t activeAnimation = 0;
 
 	~VulkanglTFModel()
 	{
@@ -201,80 +271,411 @@ public:
 		}
 	}
 
-	void loadNode(const tinygltf::Node& inputNode, const tinygltf::Model& input, VulkanglTFModel::Node* parent, std::vector<uint32_t>& indexBuffer, std::vector<VulkanglTFModel::Vertex>& vertexBuffer)
+	VulkanglTFModel::Node* findNode(Node* parent, uint32_t index)
+	{
+		Node* nodeFound = nullptr;
+		if (parent->index == index)
+		{
+			return parent;
+		}
+		for (auto& child : parent->children)
+		{
+			nodeFound = findNode(child, index);
+			if (nodeFound)
+			{
+				break;
+			}
+		}
+		return nodeFound;
+	}
+
+	VulkanglTFModel::Node* nodeFromIndex(uint32_t index)
+	{
+		Node* nodeFound = nullptr;
+		for (auto& node : nodes)
+		{
+			nodeFound = findNode(node, index);
+			if (nodeFound)
+			{
+				break;
+			}
+		}
+		return nodeFound;
+	}
+
+	//void loadNode(const tinygltf::Node& inputNode, const tinygltf::Model& input, VulkanglTFModel::Node* parent, std::vector<uint32_t>& indexBuffer, std::vector<VulkanglTFModel::Vertex>& vertexBuffer)
+	//{
+	//	VulkanglTFModel::Node* node = new VulkanglTFModel::Node{};
+	//	node->matrix = glm::mat4(1.0f);
+	//	node->parent = parent;
+
+	//	// Get the local node matrix
+	//	// It's either made up from translation, rotation, scale or a 4x4 matrix
+	//	if (inputNode.translation.size() == 3) {
+	//		node->matrix = glm::translate(node->matrix, glm::vec3(glm::make_vec3(inputNode.translation.data())));
+	//	}
+	//	if (inputNode.rotation.size() == 4) {
+	//		glm::quat q = glm::make_quat(inputNode.rotation.data());
+	//		node->matrix *= glm::mat4(q);
+	//	}
+	//	if (inputNode.scale.size() == 3) {
+	//		node->matrix = glm::scale(node->matrix, glm::vec3(glm::make_vec3(inputNode.scale.data())));
+	//	}
+	//	if (inputNode.matrix.size() == 16) {
+	//		node->matrix = glm::make_mat4x4(inputNode.matrix.data());
+	//	};
+
+	//	// Load node's children
+	//	if (inputNode.children.size() > 0) {
+	//		for (size_t i = 0; i < inputNode.children.size(); i++) {
+	//			loadNode(input.nodes[inputNode.children[i]], input , node, indexBuffer, vertexBuffer);
+	//		}
+	//	}
+
+	//	// If the node contains mesh data, we load vertices and indices from the buffers
+	//	// In glTF this is done via accessors and buffer views
+	//	if (inputNode.mesh > -1) {
+	//		const tinygltf::Mesh mesh = input.meshes[inputNode.mesh];
+	//		// Iterate through all primitives of this node's mesh
+	//		for (size_t i = 0; i < mesh.primitives.size(); i++) {
+	//			const tinygltf::Primitive& glTFPrimitive = mesh.primitives[i];
+	//			uint32_t firstIndex = static_cast<uint32_t>(indexBuffer.size());
+	//			uint32_t vertexStart = static_cast<uint32_t>(vertexBuffer.size());
+	//			uint32_t indexCount = 0;
+	//			// Vertices
+	//			{
+	//				const float* positionBuffer = nullptr;
+	//				const float* normalsBuffer = nullptr;
+	//				const float* texCoordsBuffer = nullptr;
+	//				size_t vertexCount = 0;
+
+	//				// Get buffer data for vertex positions
+	//				if (glTFPrimitive.attributes.find("POSITION") != glTFPrimitive.attributes.end()) {
+	//					const tinygltf::Accessor& accessor = input.accessors[glTFPrimitive.attributes.find("POSITION")->second];
+	//					const tinygltf::BufferView& view = input.bufferViews[accessor.bufferView];
+	//					positionBuffer = reinterpret_cast<const float*>(&(input.buffers[view.buffer].data[accessor.byteOffset + view.byteOffset]));
+	//					vertexCount = accessor.count;
+	//				}
+	//				// Get buffer data for vertex normals
+	//				if (glTFPrimitive.attributes.find("NORMAL") != glTFPrimitive.attributes.end()) {
+	//					const tinygltf::Accessor& accessor = input.accessors[glTFPrimitive.attributes.find("NORMAL")->second];
+	//					const tinygltf::BufferView& view = input.bufferViews[accessor.bufferView];
+	//					normalsBuffer = reinterpret_cast<const float*>(&(input.buffers[view.buffer].data[accessor.byteOffset + view.byteOffset]));
+	//				}
+	//				// Get buffer data for vertex texture coordinates
+	//				// glTF supports multiple sets, we only load the first one
+	//				if (glTFPrimitive.attributes.find("TEXCOORD_0") != glTFPrimitive.attributes.end()) {
+	//					const tinygltf::Accessor& accessor = input.accessors[glTFPrimitive.attributes.find("TEXCOORD_0")->second];
+	//					const tinygltf::BufferView& view = input.bufferViews[accessor.bufferView];
+	//					texCoordsBuffer = reinterpret_cast<const float*>(&(input.buffers[view.buffer].data[accessor.byteOffset + view.byteOffset]));
+	//				}
+
+	//				// Append data to model's vertex buffer
+	//				for (size_t v = 0; v < vertexCount; v++) {
+	//					Vertex vert{};
+	//					vert.pos = glm::vec4(glm::make_vec3(&positionBuffer[v * 3]), 1.0f);
+	//					vert.normal = glm::normalize(glm::vec3(normalsBuffer ? glm::make_vec3(&normalsBuffer[v * 3]) : glm::vec3(0.0f)));
+	//					vert.uv = texCoordsBuffer ? glm::make_vec2(&texCoordsBuffer[v * 2]) : glm::vec3(0.0f);
+	//					vert.color = glm::vec3(1.0f);
+	//					vertexBuffer.push_back(vert);
+	//				}
+	//			}
+	//			// Indices
+	//			{
+	//				const tinygltf::Accessor& accessor = input.accessors[glTFPrimitive.indices];
+	//				const tinygltf::BufferView& bufferView = input.bufferViews[accessor.bufferView];
+	//				const tinygltf::Buffer& buffer = input.buffers[bufferView.buffer];
+
+	//				indexCount += static_cast<uint32_t>(accessor.count);
+
+	//				// glTF supports different component types of indices
+	//				switch (accessor.componentType) {
+	//				case TINYGLTF_PARAMETER_TYPE_UNSIGNED_INT: {
+	//					const uint32_t* buf = reinterpret_cast<const uint32_t*>(&buffer.data[accessor.byteOffset + bufferView.byteOffset]);
+	//					for (size_t index = 0; index < accessor.count; index++) {
+	//						indexBuffer.push_back(buf[index] + vertexStart);
+	//					}
+	//					break;
+	//				}
+	//				case TINYGLTF_PARAMETER_TYPE_UNSIGNED_SHORT: {
+	//					const uint16_t* buf = reinterpret_cast<const uint16_t*>(&buffer.data[accessor.byteOffset + bufferView.byteOffset]);
+	//					for (size_t index = 0; index < accessor.count; index++) {
+	//						indexBuffer.push_back(buf[index] + vertexStart);
+	//					}
+	//					break;
+	//				}
+	//				case TINYGLTF_PARAMETER_TYPE_UNSIGNED_BYTE: {
+	//					const uint8_t* buf = reinterpret_cast<const uint8_t*>(&buffer.data[accessor.byteOffset + bufferView.byteOffset]);
+	//					for (size_t index = 0; index < accessor.count; index++) {
+	//						indexBuffer.push_back(buf[index] + vertexStart);
+	//					}
+	//					break;
+	//				}
+	//				default:
+	//					std::cerr << "Index component type " << accessor.componentType << " not supported!" << std::endl;
+	//					return;
+	//				}
+	//			}
+	//			Primitive primitive{};
+	//			primitive.firstIndex = firstIndex;
+	//			primitive.indexCount = indexCount;
+	//			primitive.materialIndex = glTFPrimitive.material;
+	//			node->mesh.primitives.push_back(primitive);
+	//		}
+	//	}
+
+	//	if (parent) {
+	//		parent->children.push_back(node);
+	//	}
+	//	else {
+	//		nodes.push_back(node);
+	//	}
+	//}
+
+	// POI: Load the skins from the glTF model
+	void loadSkins(tinygltf::Model& input)
+	{
+		skins.resize(input.skins.size());
+
+		for (size_t i = 0; i < input.skins.size(); i++)
+		{
+			tinygltf::Skin glTFSkin = input.skins[i];
+
+			skins[i].name = glTFSkin.name;
+			// Find the root node of the skeleton
+			skins[i].skeletonRoot = nodeFromIndex(glTFSkin.skeleton);
+
+			// Find joint nodes
+			for (int jointIndex : glTFSkin.joints)
+			{
+				Node* node = nodeFromIndex(jointIndex);
+				if (node)
+				{
+					skins[i].joints.push_back(node);
+				}
+			}
+
+			// Get the inverse bind matrices from the buffer associated to this skin
+			if (glTFSkin.inverseBindMatrices > -1)
+			{
+				const tinygltf::Accessor& accessor = input.accessors[glTFSkin.inverseBindMatrices];
+				const tinygltf::BufferView& bufferView = input.bufferViews[accessor.bufferView];
+				const tinygltf::Buffer& buffer = input.buffers[bufferView.buffer];
+				skins[i].inverseBindMatrices.resize(accessor.count);
+				memcpy(skins[i].inverseBindMatrices.data(), &buffer.data[accessor.byteOffset + bufferView.byteOffset], accessor.count * sizeof(glm::mat4));
+
+				// Store inverse bind matrices for this skin in a shader storage buffer object
+				// To keep this sample simple, we create a host visible shader storage buffer
+				VK_CHECK_RESULT(vulkanDevice->createBuffer(
+					VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
+					VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
+					&skins[i].ssbo,
+					sizeof(glm::mat4) * skins[i].inverseBindMatrices.size(),
+					skins[i].inverseBindMatrices.data()));
+				VK_CHECK_RESULT(skins[i].ssbo.map());
+			}
+		}
+	}
+
+	// POI: Load the animations from the glTF model
+	void loadAnimations(tinygltf::Model& input)
+	{
+		animations.resize(input.animations.size());
+
+		for (size_t i = 0; i < input.animations.size(); i++)
+		{
+			tinygltf::Animation glTFAnimation = input.animations[i];
+			animations[i].name = glTFAnimation.name;
+
+			// Samplers
+			animations[i].samplers.resize(glTFAnimation.samplers.size());
+			for (size_t j = 0; j < glTFAnimation.samplers.size(); j++)
+			{
+				tinygltf::AnimationSampler glTFSampler = glTFAnimation.samplers[j];
+				AnimationSampler& dstSampler = animations[i].samplers[j];
+				dstSampler.interpolation = glTFSampler.interpolation;
+
+				// Read sampler keyframe input time values
+				{
+					const tinygltf::Accessor& accessor = input.accessors[glTFSampler.input];
+					const tinygltf::BufferView& bufferView = input.bufferViews[accessor.bufferView];
+					const tinygltf::Buffer& buffer = input.buffers[bufferView.buffer];
+					const void* dataPtr = &buffer.data[accessor.byteOffset + bufferView.byteOffset];
+					const float* buf = static_cast<const float*>(dataPtr);
+					for (size_t index = 0; index < accessor.count; index++)
+					{
+						dstSampler.inputs.push_back(buf[index]);
+					}
+					// Adjust animation's start and end times
+					for (auto input : animations[i].samplers[j].inputs)
+					{
+						if (input < animations[i].start)
+						{
+							animations[i].start = input;
+						};
+						if (input > animations[i].end)
+						{
+							animations[i].end = input;
+						}
+					}
+				}
+
+				// Read sampler keyframe output translate/rotate/scale values
+				{
+					const tinygltf::Accessor& accessor = input.accessors[glTFSampler.output];
+					const tinygltf::BufferView& bufferView = input.bufferViews[accessor.bufferView];
+					const tinygltf::Buffer& buffer = input.buffers[bufferView.buffer];
+					const void* dataPtr = &buffer.data[accessor.byteOffset + bufferView.byteOffset];
+					switch (accessor.type)
+					{
+					case TINYGLTF_TYPE_VEC3: {
+						const glm::vec3* buf = static_cast<const glm::vec3*>(dataPtr);
+						for (size_t index = 0; index < accessor.count; index++)
+						{
+							dstSampler.outputsVec4.push_back(glm::vec4(buf[index], 0.0f));
+						}
+						break;
+					}
+					case TINYGLTF_TYPE_VEC4: {
+						const glm::vec4* buf = static_cast<const glm::vec4*>(dataPtr);
+						for (size_t index = 0; index < accessor.count; index++)
+						{
+							dstSampler.outputsVec4.push_back(buf[index]);
+						}
+						break;
+					}
+					default: {
+						std::cout << "unknown type" << std::endl;
+						break;
+					}
+					}
+				}
+			}
+
+			// Channels
+			animations[i].channels.resize(glTFAnimation.channels.size());
+			for (size_t j = 0; j < glTFAnimation.channels.size(); j++)
+			{
+				tinygltf::AnimationChannel glTFChannel = glTFAnimation.channels[j];
+				AnimationChannel& dstChannel = animations[i].channels[j];
+				dstChannel.path = glTFChannel.target_path;
+				dstChannel.samplerIndex = glTFChannel.sampler;
+				dstChannel.node = nodeFromIndex(glTFChannel.target_node);
+			}
+		}
+	}
+
+	void VulkanglTFModel::loadNode(const tinygltf::Node& inputNode, const tinygltf::Model& input, VulkanglTFModel::Node* parent, uint32_t nodeIndex, std::vector<uint32_t>& indexBuffer, std::vector<VulkanglTFModel::Vertex>& vertexBuffer)
 	{
 		VulkanglTFModel::Node* node = new VulkanglTFModel::Node{};
-		node->matrix = glm::mat4(1.0f);
 		node->parent = parent;
+		node->matrix = glm::mat4(1.0f);
+		node->index = nodeIndex;
+		node->skin = inputNode.skin;
 
 		// Get the local node matrix
 		// It's either made up from translation, rotation, scale or a 4x4 matrix
-		if (inputNode.translation.size() == 3) {
-			node->matrix = glm::translate(node->matrix, glm::vec3(glm::make_vec3(inputNode.translation.data())));
+		if (inputNode.translation.size() == 3)
+		{
+			node->translation = glm::make_vec3(inputNode.translation.data());
 		}
-		if (inputNode.rotation.size() == 4) {
+		if (inputNode.rotation.size() == 4)
+		{
 			glm::quat q = glm::make_quat(inputNode.rotation.data());
-			node->matrix *= glm::mat4(q);
+			node->rotation = glm::mat4(q);
 		}
-		if (inputNode.scale.size() == 3) {
-			node->matrix = glm::scale(node->matrix, glm::vec3(glm::make_vec3(inputNode.scale.data())));
+		if (inputNode.scale.size() == 3)
+		{
+			node->scale = glm::make_vec3(inputNode.scale.data());
 		}
-		if (inputNode.matrix.size() == 16) {
+		if (inputNode.matrix.size() == 16)
+		{
 			node->matrix = glm::make_mat4x4(inputNode.matrix.data());
 		};
 
 		// Load node's children
-		if (inputNode.children.size() > 0) {
-			for (size_t i = 0; i < inputNode.children.size(); i++) {
-				loadNode(input.nodes[inputNode.children[i]], input , node, indexBuffer, vertexBuffer);
+		if (inputNode.children.size() > 0)
+		{
+			for (size_t i = 0; i < inputNode.children.size(); i++)
+			{
+				loadNode(input.nodes[inputNode.children[i]], input, node, inputNode.children[i], indexBuffer, vertexBuffer);
 			}
 		}
 
 		// If the node contains mesh data, we load vertices and indices from the buffers
 		// In glTF this is done via accessors and buffer views
-		if (inputNode.mesh > -1) {
+		if (inputNode.mesh > -1)
+		{
 			const tinygltf::Mesh mesh = input.meshes[inputNode.mesh];
 			// Iterate through all primitives of this node's mesh
-			for (size_t i = 0; i < mesh.primitives.size(); i++) {
+			for (size_t i = 0; i < mesh.primitives.size(); i++)
+			{
 				const tinygltf::Primitive& glTFPrimitive = mesh.primitives[i];
-				uint32_t firstIndex = static_cast<uint32_t>(indexBuffer.size());
-				uint32_t vertexStart = static_cast<uint32_t>(vertexBuffer.size());
-				uint32_t indexCount = 0;
+				uint32_t                   firstIndex = static_cast<uint32_t>(indexBuffer.size());
+				uint32_t                   vertexStart = static_cast<uint32_t>(vertexBuffer.size());
+				uint32_t                   indexCount = 0;
+				bool                       hasSkin = false;
 				// Vertices
 				{
 					const float* positionBuffer = nullptr;
 					const float* normalsBuffer = nullptr;
 					const float* texCoordsBuffer = nullptr;
-					size_t vertexCount = 0;
+					const uint16_t* jointIndicesBuffer = nullptr;
+					const float* jointWeightsBuffer = nullptr;
+					size_t          vertexCount = 0;
 
-					// Get buffer data for vertex positions
-					if (glTFPrimitive.attributes.find("POSITION") != glTFPrimitive.attributes.end()) {
+					// Get buffer data for vertex normals
+					if (glTFPrimitive.attributes.find("POSITION") != glTFPrimitive.attributes.end())
+					{
 						const tinygltf::Accessor& accessor = input.accessors[glTFPrimitive.attributes.find("POSITION")->second];
 						const tinygltf::BufferView& view = input.bufferViews[accessor.bufferView];
 						positionBuffer = reinterpret_cast<const float*>(&(input.buffers[view.buffer].data[accessor.byteOffset + view.byteOffset]));
 						vertexCount = accessor.count;
 					}
 					// Get buffer data for vertex normals
-					if (glTFPrimitive.attributes.find("NORMAL") != glTFPrimitive.attributes.end()) {
+					if (glTFPrimitive.attributes.find("NORMAL") != glTFPrimitive.attributes.end())
+					{
 						const tinygltf::Accessor& accessor = input.accessors[glTFPrimitive.attributes.find("NORMAL")->second];
 						const tinygltf::BufferView& view = input.bufferViews[accessor.bufferView];
 						normalsBuffer = reinterpret_cast<const float*>(&(input.buffers[view.buffer].data[accessor.byteOffset + view.byteOffset]));
 					}
 					// Get buffer data for vertex texture coordinates
 					// glTF supports multiple sets, we only load the first one
-					if (glTFPrimitive.attributes.find("TEXCOORD_0") != glTFPrimitive.attributes.end()) {
+					if (glTFPrimitive.attributes.find("TEXCOORD_0") != glTFPrimitive.attributes.end())
+					{
 						const tinygltf::Accessor& accessor = input.accessors[glTFPrimitive.attributes.find("TEXCOORD_0")->second];
 						const tinygltf::BufferView& view = input.bufferViews[accessor.bufferView];
 						texCoordsBuffer = reinterpret_cast<const float*>(&(input.buffers[view.buffer].data[accessor.byteOffset + view.byteOffset]));
 					}
 
+					// POI: Get buffer data required for vertex skinning
+					// Get vertex joint indices
+					if (glTFPrimitive.attributes.find("JOINTS_0") != glTFPrimitive.attributes.end())
+					{
+						const tinygltf::Accessor& accessor = input.accessors[glTFPrimitive.attributes.find("JOINTS_0")->second];
+						const tinygltf::BufferView& view = input.bufferViews[accessor.bufferView];
+						jointIndicesBuffer = reinterpret_cast<const uint16_t*>(&(input.buffers[view.buffer].data[accessor.byteOffset + view.byteOffset]));
+					}
+					// Get vertex joint weights
+					if (glTFPrimitive.attributes.find("WEIGHTS_0") != glTFPrimitive.attributes.end())
+					{
+						const tinygltf::Accessor& accessor = input.accessors[glTFPrimitive.attributes.find("WEIGHTS_0")->second];
+						const tinygltf::BufferView& view = input.bufferViews[accessor.bufferView];
+						jointWeightsBuffer = reinterpret_cast<const float*>(&(input.buffers[view.buffer].data[accessor.byteOffset + view.byteOffset]));
+					}
+
+					hasSkin = (jointIndicesBuffer && jointWeightsBuffer);
+
 					// Append data to model's vertex buffer
-					for (size_t v = 0; v < vertexCount; v++) {
+					for (size_t v = 0; v < vertexCount; v++)
+					{
 						Vertex vert{};
 						vert.pos = glm::vec4(glm::make_vec3(&positionBuffer[v * 3]), 1.0f);
 						vert.normal = glm::normalize(glm::vec3(normalsBuffer ? glm::make_vec3(&normalsBuffer[v * 3]) : glm::vec3(0.0f)));
 						vert.uv = texCoordsBuffer ? glm::make_vec2(&texCoordsBuffer[v * 2]) : glm::vec3(0.0f);
 						vert.color = glm::vec3(1.0f);
+						vert.jointIndices = hasSkin ? glm::vec4(glm::make_vec4(&jointIndicesBuffer[v * 4])) : glm::vec4(0.0f);
+						vert.jointWeights = hasSkin ? glm::make_vec4(&jointWeightsBuffer[v * 4]) : glm::vec4(0.0f);
 						vertexBuffer.push_back(vert);
 					}
 				}
@@ -287,24 +688,28 @@ public:
 					indexCount += static_cast<uint32_t>(accessor.count);
 
 					// glTF supports different component types of indices
-					switch (accessor.componentType) {
+					switch (accessor.componentType)
+					{
 					case TINYGLTF_PARAMETER_TYPE_UNSIGNED_INT: {
 						const uint32_t* buf = reinterpret_cast<const uint32_t*>(&buffer.data[accessor.byteOffset + bufferView.byteOffset]);
-						for (size_t index = 0; index < accessor.count; index++) {
+						for (size_t index = 0; index < accessor.count; index++)
+						{
 							indexBuffer.push_back(buf[index] + vertexStart);
 						}
 						break;
 					}
 					case TINYGLTF_PARAMETER_TYPE_UNSIGNED_SHORT: {
 						const uint16_t* buf = reinterpret_cast<const uint16_t*>(&buffer.data[accessor.byteOffset + bufferView.byteOffset]);
-						for (size_t index = 0; index < accessor.count; index++) {
+						for (size_t index = 0; index < accessor.count; index++)
+						{
 							indexBuffer.push_back(buf[index] + vertexStart);
 						}
 						break;
 					}
 					case TINYGLTF_PARAMETER_TYPE_UNSIGNED_BYTE: {
 						const uint8_t* buf = reinterpret_cast<const uint8_t*>(&buffer.data[accessor.byteOffset + bufferView.byteOffset]);
-						for (size_t index = 0; index < accessor.count; index++) {
+						for (size_t index = 0; index < accessor.count; index++)
+						{
 							indexBuffer.push_back(buf[index] + vertexStart);
 						}
 						break;
@@ -322,44 +727,183 @@ public:
 			}
 		}
 
-		if (parent) {
+		if (parent)
+		{
 			parent->children.push_back(node);
 		}
-		else {
+		else
+		{
 			nodes.push_back(node);
 		}
 	}
+	
+
+	// POI: Traverse the node hierarchy to the top-most parent to get the local matrix of the given node
+	glm::mat4 VulkanglTFModel::getNodeMatrix(VulkanglTFModel::Node* node)
+	{
+		glm::mat4              nodeMatrix = node->getLocalMatrix();
+		VulkanglTFModel::Node* currentParent = node->parent;
+		while (currentParent)
+		{
+			nodeMatrix = currentParent->getLocalMatrix() * nodeMatrix;
+			currentParent = currentParent->parent;
+		}
+		return nodeMatrix;
+	}
+
+	// POI: Update the joint matrices from the current animation frame and pass them to the GPU
+	void updateJoints(VulkanglTFModel::Node* node)
+	{
+		if (node->skin > -1)
+		{
+			// Update the joint matrices
+			glm::mat4              inverseTransform = glm::inverse(getNodeMatrix(node));
+			Skin                   skin = skins[node->skin];
+			size_t                 numJoints = (uint32_t)skin.joints.size();
+			std::vector<glm::mat4> jointMatrices(numJoints);
+			for (size_t i = 0; i < numJoints; i++)
+			{
+				jointMatrices[i] = getNodeMatrix(skin.joints[i]) * skin.inverseBindMatrices[i];
+				jointMatrices[i] = inverseTransform * jointMatrices[i];
+			}
+			// Update ssbo
+			skin.ssbo.copyTo(jointMatrices.data(), jointMatrices.size() * sizeof(glm::mat4));
+		}
+
+		for (auto& child : node->children)
+		{
+			updateJoints(child);
+		}
+	}
+
+	// POI: Update the current animation
+	void updateAnimation(float deltaTime)
+	{
+		if (activeAnimation > static_cast<uint32_t>(animations.size()) - 1)
+		{
+			std::cout << "No animation with index " << activeAnimation << std::endl;
+			return;
+		}
+		Animation& animation = animations[activeAnimation];
+		animation.currentTime += deltaTime;
+		if (animation.currentTime > animation.end)
+		{
+			animation.currentTime -= animation.end;
+		}
+
+		for (auto& channel : animation.channels)
+		{
+			AnimationSampler& sampler = animation.samplers[channel.samplerIndex];
+			for (size_t i = 0; i < sampler.inputs.size() - 1; i++)
+			{
+				if (sampler.interpolation != "LINEAR")
+				{
+					std::cout << "This sample only supports linear interpolations\n";
+					continue;
+				}
+
+				// Get the input keyframe values for the current time stamp
+				if ((animation.currentTime >= sampler.inputs[i]) && (animation.currentTime <= sampler.inputs[i + 1]))
+				{
+					float a = (animation.currentTime - sampler.inputs[i]) / (sampler.inputs[i + 1] - sampler.inputs[i]);
+					if (channel.path == "translation")
+					{
+						channel.node->translation = glm::mix(sampler.outputsVec4[i], sampler.outputsVec4[i + 1], a);
+					}
+					if (channel.path == "rotation")
+					{
+						glm::quat q1;
+						q1.x = sampler.outputsVec4[i].x;
+						q1.y = sampler.outputsVec4[i].y;
+						q1.z = sampler.outputsVec4[i].z;
+						q1.w = sampler.outputsVec4[i].w;
+
+						glm::quat q2;
+						q2.x = sampler.outputsVec4[i + 1].x;
+						q2.y = sampler.outputsVec4[i + 1].y;
+						q2.z = sampler.outputsVec4[i + 1].z;
+						q2.w = sampler.outputsVec4[i + 1].w;
+
+						channel.node->rotation = glm::normalize(glm::slerp(q1, q2, a));
+					}
+					if (channel.path == "scale")
+					{
+						channel.node->scale = glm::mix(sampler.outputsVec4[i], sampler.outputsVec4[i + 1], a);
+					}
+				}
+			}
+		}
+		for (auto& node : nodes)
+		{
+			updateJoints(node);
+		}
+	}
 
 	/*
 		glTF rendering functions
 	*/
 
 	// Draw a single node including child nodes (if present)
-	void drawNode(VkCommandBuffer commandBuffer, VkPipelineLayout pipelineLayout, VulkanglTFModel::Node* node)
+	//void drawNode(VkCommandBuffer commandBuffer, VkPipelineLayout pipelineLayout, VulkanglTFModel::Node* node)
+	//{
+	//	if (node->mesh.primitives.size() > 0) {
+	//		// Pass the node's matrix via push constants
+	//		// Traverse the node hierarchy to the top-most parent to get the final matrix of the current node
+	//		glm::mat4 nodeMatrix = node->matrix;
+	//		VulkanglTFModel::Node* currentParent = node->parent;
+	//		while (currentParent) {
+	//			nodeMatrix = currentParent->matrix * nodeMatrix;
+	//			currentParent = currentParent->parent;
+	//		}
+	//		// Pass the final matrix to the vertex shader using push constants
+	//		vkCmdPushConstants(commandBuffer, pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(glm::mat4), &nodeMatrix);
+	//		for (VulkanglTFModel::Primitive& primitive : node->mesh.primitives) {
+	//			if (primitive.indexCount > 0) {
+	//				// Get the texture index for this primitive
+	//				VulkanglTFModel::Texture texture = textures[materials[primitive.materialIndex].baseColorTextureIndex];
+	//				// Bind the descriptor for the current primitive's texture
+	//				vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 1, 1, &images[texture.imageIndex].descriptorSet, 0, nullptr);
+	//				vkCmdDrawIndexed(commandBuffer, primitive.indexCount, 1, primitive.firstIndex, 0, 0);
+	//			}
+	//		}
+	//	}
+	//	for (auto& child : node->children) {
+	//		drawNode(commandBuffer, pipelineLayout, child);
+	//	}
+	//}
+	// Draw a single node including child nodes (if present)
+	void VulkanglTFModel::drawNode(VkCommandBuffer commandBuffer, VkPipelineLayout pipelineLayout, VulkanglTFModel::Node node)
 	{
-		if (node->mesh.primitives.size() > 0) {
+		if (node.mesh.primitives.size() > 0)
+		{
 			// Pass the node's matrix via push constants
 			// Traverse the node hierarchy to the top-most parent to get the final matrix of the current node
-			glm::mat4 nodeMatrix = node->matrix;
-			VulkanglTFModel::Node* currentParent = node->parent;
-			while (currentParent) {
+			glm::mat4              nodeMatrix = node.matrix;
+			VulkanglTFModel::Node* currentParent = node.parent;
+			while (currentParent)
+			{
 				nodeMatrix = currentParent->matrix * nodeMatrix;
 				currentParent = currentParent->parent;
 			}
 			// Pass the final matrix to the vertex shader using push constants
 			vkCmdPushConstants(commandBuffer, pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(glm::mat4), &nodeMatrix);
-			for (VulkanglTFModel::Primitive& primitive : node->mesh.primitives) {
-				if (primitive.indexCount > 0) {
+			// Bind SSBO with skin data for this node to set 1
+			//vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 1, 1, &skins[node.skin].descriptorSet, 0, nullptr);
+			for (VulkanglTFModel::Primitive& primitive : node.mesh.primitives)
+			{
+				if (primitive.indexCount > 0)
+				{
 					// Get the texture index for this primitive
 					VulkanglTFModel::Texture texture = textures[materials[primitive.materialIndex].baseColorTextureIndex];
-					// Bind the descriptor for the current primitive's texture
-					vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 1, 1, &images[texture.imageIndex].descriptorSet, 0, nullptr);
+					// Bind the descriptor for the current primitive's texture to set 2
+					vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 2, 1, &images[texture.imageIndex].descriptorSet, 0, nullptr);
 					vkCmdDrawIndexed(commandBuffer, primitive.indexCount, 1, primitive.firstIndex, 0, 0);
 				}
 			}
 		}
-		for (auto& child : node->children) {
-			drawNode(commandBuffer, pipelineLayout, child);
+		for (auto& child : node.children)
+		{
+			drawNode(commandBuffer, pipelineLayout, *child);
 		}
 	}
 
@@ -372,7 +916,7 @@ public:
 		vkCmdBindIndexBuffer(commandBuffer, indices.buffer, 0, VK_INDEX_TYPE_UINT32);
 		// Render all nodes at top-level
 		for (auto& node : nodes) {
-			drawNode(commandBuffer, pipelineLayout, node);
+			drawNode(commandBuffer, pipelineLayout, *node);
 		}
 	}
 
@@ -406,6 +950,7 @@ public:
 	struct DescriptorSetLayouts {
 		VkDescriptorSetLayout matrices;
 		VkDescriptorSetLayout textures;
+		VkDescriptorSetLayout jointMatrices;
 	} descriptorSetLayouts;
 
 	VulkanExample() : VulkanExampleBase(ENABLE_VALIDATION)
@@ -430,6 +975,7 @@ public:
 		vkDestroyPipelineLayout(device, pipelineLayout, nullptr);
 		vkDestroyDescriptorSetLayout(device, descriptorSetLayouts.matrices, nullptr);
 		vkDestroyDescriptorSetLayout(device, descriptorSetLayouts.textures, nullptr);
+		vkDestroyDescriptorSetLayout(device, descriptorSetLayouts.jointMatrices, nullptr);
 
 		shaderData.buffer.destroy();
 	}
@@ -509,7 +1055,15 @@ public:
 			const tinygltf::Scene& scene = glTFInput.scenes[0];
 			for (size_t i = 0; i < scene.nodes.size(); i++) {
 				const tinygltf::Node node = glTFInput.nodes[scene.nodes[i]];
-				glTFModel.loadNode(node, glTFInput, nullptr, indexBuffer, vertexBuffer);
+				//glTFModel.loadNode(node, glTFInput, nullptr, indexBuffer, vertexBuffer);
+				glTFModel.loadNode(node, glTFInput, nullptr, scene.nodes[i], indexBuffer, vertexBuffer);
+			}
+			glTFModel.loadSkins(glTFInput);
+			glTFModel.loadAnimations(glTFInput);
+			// Calculate initial pose
+			for (auto node : glTFModel.nodes)
+			{
+				glTFModel.updateJoints(node);
 			}
 		}
 		else {
@@ -593,9 +1147,57 @@ public:
 	void loadAssets()
 	{
 		loadglTFFile(getAssetPath() + "buster_drone/busterDrone.gltf");
+		//loadglTFFile(getAssetPath() + "models/CesiumMan/glTF/CesiumMan.gltf");
 	}
 
-	void setupDescriptors()
+	//void setupDescriptors()
+	//{
+	//	/*
+	//		This sample uses separate descriptor sets (and layouts) for the matrices and materials (textures)
+	//	*/
+
+	//	std::vector<VkDescriptorPoolSize> poolSizes = {
+	//		vks::initializers::descriptorPoolSize(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1),
+	//		// One combined image sampler per model image/texture
+	//		vks::initializers::descriptorPoolSize(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, static_cast<uint32_t>(glTFModel.images.size())),
+	//	};
+	//	// One set for matrices and one per model image/texture
+	//	const uint32_t maxSetCount = static_cast<uint32_t>(glTFModel.images.size()) + 1;
+	//	VkDescriptorPoolCreateInfo descriptorPoolInfo = vks::initializers::descriptorPoolCreateInfo(poolSizes, maxSetCount);
+	//	VK_CHECK_RESULT(vkCreateDescriptorPool(device, &descriptorPoolInfo, nullptr, &descriptorPool));
+
+	//	// Descriptor set layout for passing matrices
+	//	VkDescriptorSetLayoutBinding setLayoutBinding = vks::initializers::descriptorSetLayoutBinding(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_VERTEX_BIT, 0);
+	//	VkDescriptorSetLayoutCreateInfo descriptorSetLayoutCI = vks::initializers::descriptorSetLayoutCreateInfo(&setLayoutBinding, 1);
+	//	VK_CHECK_RESULT(vkCreateDescriptorSetLayout(device, &descriptorSetLayoutCI, nullptr, &descriptorSetLayouts.matrices));
+	//	// Descriptor set layout for passing material textures
+	//	setLayoutBinding = vks::initializers::descriptorSetLayoutBinding(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, 0);
+	//	VK_CHECK_RESULT(vkCreateDescriptorSetLayout(device, &descriptorSetLayoutCI, nullptr, &descriptorSetLayouts.textures));
+	//	// Pipeline layout using both descriptor sets (set 0 = matrices, set 1 = material)
+	//	std::array<VkDescriptorSetLayout, 2> setLayouts = { descriptorSetLayouts.matrices, descriptorSetLayouts.textures };
+	//	VkPipelineLayoutCreateInfo pipelineLayoutCI= vks::initializers::pipelineLayoutCreateInfo(setLayouts.data(), static_cast<uint32_t>(setLayouts.size()));
+	//	// We will use push constants to push the local matrices of a primitive to the vertex shader
+	//	VkPushConstantRange pushConstantRange = vks::initializers::pushConstantRange(VK_SHADER_STAGE_VERTEX_BIT, sizeof(glm::mat4), 0);
+	//	// Push constant ranges are part of the pipeline layout
+	//	pipelineLayoutCI.pushConstantRangeCount = 1;
+	//	pipelineLayoutCI.pPushConstantRanges = &pushConstantRange;
+	//	VK_CHECK_RESULT(vkCreatePipelineLayout(device, &pipelineLayoutCI, nullptr, &pipelineLayout));
+
+	//	// Descriptor set for scene matrices
+	//	VkDescriptorSetAllocateInfo allocInfo = vks::initializers::descriptorSetAllocateInfo(descriptorPool, &descriptorSetLayouts.matrices, 1);
+	//	VK_CHECK_RESULT(vkAllocateDescriptorSets(device, &allocInfo, &descriptorSet));
+	//	VkWriteDescriptorSet writeDescriptorSet = vks::initializers::writeDescriptorSet(descriptorSet, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 0, &shaderData.buffer.descriptor);
+	//	vkUpdateDescriptorSets(device, 1, &writeDescriptorSet, 0, nullptr);
+	//	// Descriptor sets for materials
+	//	for (auto& image : glTFModel.images) {
+	//		const VkDescriptorSetAllocateInfo allocInfo = vks::initializers::descriptorSetAllocateInfo(descriptorPool, &descriptorSetLayouts.textures, 1);
+	//		VK_CHECK_RESULT(vkAllocateDescriptorSets(device, &allocInfo, &image.descriptorSet));
+	//		VkWriteDescriptorSet writeDescriptorSet = vks::initializers::writeDescriptorSet(image.descriptorSet, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 0, &image.texture.descriptor);
+	//		vkUpdateDescriptorSets(device, 1, &writeDescriptorSet, 0, nullptr);
+	//	}
+	//}
+
+	void VulkanExample::setupDescriptors()
 	{
 		/*
 			This sample uses separate descriptor sets (and layouts) for the matrices and materials (textures)
@@ -603,24 +1205,42 @@ public:
 
 		std::vector<VkDescriptorPoolSize> poolSizes = {
 			vks::initializers::descriptorPoolSize(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1),
-			// One combined image sampler per model image/texture
+			// One combined image sampler per material image/texture
 			vks::initializers::descriptorPoolSize(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, static_cast<uint32_t>(glTFModel.images.size())),
+			// One ssbo per skin
+			vks::initializers::descriptorPoolSize(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, static_cast<uint32_t>(glTFModel.skins.size())),
 		};
-		// One set for matrices and one per model image/texture
-		const uint32_t maxSetCount = static_cast<uint32_t>(glTFModel.images.size()) + 1;
+		// Number of descriptor sets = One for the scene ubo + one per image + one per skin
+		const uint32_t             maxSetCount = static_cast<uint32_t>(glTFModel.images.size()) + static_cast<uint32_t>(glTFModel.skins.size()) + 1;
 		VkDescriptorPoolCreateInfo descriptorPoolInfo = vks::initializers::descriptorPoolCreateInfo(poolSizes, maxSetCount);
 		VK_CHECK_RESULT(vkCreateDescriptorPool(device, &descriptorPoolInfo, nullptr, &descriptorPool));
 
-		// Descriptor set layout for passing matrices
-		VkDescriptorSetLayoutBinding setLayoutBinding = vks::initializers::descriptorSetLayoutBinding(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_VERTEX_BIT, 0);
+		// Descriptor set layouts
+		VkDescriptorSetLayoutBinding    setLayoutBinding{};
 		VkDescriptorSetLayoutCreateInfo descriptorSetLayoutCI = vks::initializers::descriptorSetLayoutCreateInfo(&setLayoutBinding, 1);
+
+		// Descriptor set layout for passing matrices
+		setLayoutBinding = vks::initializers::descriptorSetLayoutBinding(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_VERTEX_BIT, 0);
 		VK_CHECK_RESULT(vkCreateDescriptorSetLayout(device, &descriptorSetLayoutCI, nullptr, &descriptorSetLayouts.matrices));
+
 		// Descriptor set layout for passing material textures
 		setLayoutBinding = vks::initializers::descriptorSetLayoutBinding(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, 0);
 		VK_CHECK_RESULT(vkCreateDescriptorSetLayout(device, &descriptorSetLayoutCI, nullptr, &descriptorSetLayouts.textures));
-		// Pipeline layout using both descriptor sets (set 0 = matrices, set 1 = material)
-		std::array<VkDescriptorSetLayout, 2> setLayouts = { descriptorSetLayouts.matrices, descriptorSetLayouts.textures };
-		VkPipelineLayoutCreateInfo pipelineLayoutCI= vks::initializers::pipelineLayoutCreateInfo(setLayouts.data(), static_cast<uint32_t>(setLayouts.size()));
+
+		// Descriptor set layout for passing skin joint matrices
+		setLayoutBinding = vks::initializers::descriptorSetLayoutBinding(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_SHADER_STAGE_VERTEX_BIT, 0);
+		VK_CHECK_RESULT(vkCreateDescriptorSetLayout(device, &descriptorSetLayoutCI, nullptr, &descriptorSetLayouts.jointMatrices));
+
+		// The pipeline layout uses three sets:
+		// Set 0 = Scene matrices (VS)
+		// Set 1 = Joint matrices (VS)
+		// Set 2 = Material texture (FS)
+		std::array<VkDescriptorSetLayout, 3> setLayouts = {
+			descriptorSetLayouts.matrices,
+			descriptorSetLayouts.jointMatrices,
+			descriptorSetLayouts.textures };
+		VkPipelineLayoutCreateInfo pipelineLayoutCI = vks::initializers::pipelineLayoutCreateInfo(setLayouts.data(), static_cast<uint32_t>(setLayouts.size()));
+
 		// We will use push constants to push the local matrices of a primitive to the vertex shader
 		VkPushConstantRange pushConstantRange = vks::initializers::pushConstantRange(VK_SHADER_STAGE_VERTEX_BIT, sizeof(glm::mat4), 0);
 		// Push constant ranges are part of the pipeline layout
@@ -633,8 +1253,19 @@ public:
 		VK_CHECK_RESULT(vkAllocateDescriptorSets(device, &allocInfo, &descriptorSet));
 		VkWriteDescriptorSet writeDescriptorSet = vks::initializers::writeDescriptorSet(descriptorSet, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 0, &shaderData.buffer.descriptor);
 		vkUpdateDescriptorSets(device, 1, &writeDescriptorSet, 0, nullptr);
-		// Descriptor sets for materials
-		for (auto& image : glTFModel.images) {
+
+		// Descriptor set for glTF model skin joint matrices
+		for (auto& skin : glTFModel.skins)
+		{
+			const VkDescriptorSetAllocateInfo allocInfo = vks::initializers::descriptorSetAllocateInfo(descriptorPool, &descriptorSetLayouts.jointMatrices, 1);
+			VK_CHECK_RESULT(vkAllocateDescriptorSets(device, &allocInfo, &skin.descriptorSet));
+			VkWriteDescriptorSet writeDescriptorSet = vks::initializers::writeDescriptorSet(skin.descriptorSet, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 0, &skin.ssbo.descriptor);
+			vkUpdateDescriptorSets(device, 1, &writeDescriptorSet, 0, nullptr);
+		}
+
+		// Descriptor sets for glTF model materials
+		for (auto& image : glTFModel.images)
+		{
 			const VkDescriptorSetAllocateInfo allocInfo = vks::initializers::descriptorSetAllocateInfo(descriptorPool, &descriptorSetLayouts.textures, 1);
 			VK_CHECK_RESULT(vkAllocateDescriptorSets(device, &allocInfo, &image.descriptorSet));
 			VkWriteDescriptorSet writeDescriptorSet = vks::initializers::writeDescriptorSet(image.descriptorSet, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 0, &image.texture.descriptor);
@@ -657,11 +1288,20 @@ public:
 		const std::vector<VkVertexInputBindingDescription> vertexInputBindings = {
 			vks::initializers::vertexInputBindingDescription(0, sizeof(VulkanglTFModel::Vertex), VK_VERTEX_INPUT_RATE_VERTEX),
 		};
+		//const std::vector<VkVertexInputAttributeDescription> vertexInputAttributes = {
+		//	vks::initializers::vertexInputAttributeDescription(0, 0, VK_FORMAT_R32G32B32_SFLOAT, offsetof(VulkanglTFModel::Vertex, pos)),	// Location 0: Position
+		//	vks::initializers::vertexInputAttributeDescription(0, 1, VK_FORMAT_R32G32B32_SFLOAT, offsetof(VulkanglTFModel::Vertex, normal)),// Location 1: Normal
+		//	vks::initializers::vertexInputAttributeDescription(0, 2, VK_FORMAT_R32G32B32_SFLOAT, offsetof(VulkanglTFModel::Vertex, uv)),	// Location 2: Texture coordinates
+		//	vks::initializers::vertexInputAttributeDescription(0, 3, VK_FORMAT_R32G32B32_SFLOAT, offsetof(VulkanglTFModel::Vertex, color)),	// Location 3: Color
+		//};
 		const std::vector<VkVertexInputAttributeDescription> vertexInputAttributes = {
-			vks::initializers::vertexInputAttributeDescription(0, 0, VK_FORMAT_R32G32B32_SFLOAT, offsetof(VulkanglTFModel::Vertex, pos)),	// Location 0: Position
-			vks::initializers::vertexInputAttributeDescription(0, 1, VK_FORMAT_R32G32B32_SFLOAT, offsetof(VulkanglTFModel::Vertex, normal)),// Location 1: Normal
-			vks::initializers::vertexInputAttributeDescription(0, 2, VK_FORMAT_R32G32B32_SFLOAT, offsetof(VulkanglTFModel::Vertex, uv)),	// Location 2: Texture coordinates
-			vks::initializers::vertexInputAttributeDescription(0, 3, VK_FORMAT_R32G32B32_SFLOAT, offsetof(VulkanglTFModel::Vertex, color)),	// Location 3: Color
+		{0, 0, VK_FORMAT_R32G32B32_SFLOAT, offsetof(VulkanglTFModel::Vertex, pos)},
+		{1, 0, VK_FORMAT_R32G32B32_SFLOAT, offsetof(VulkanglTFModel::Vertex, normal)},
+		{2, 0, VK_FORMAT_R32G32B32_SFLOAT, offsetof(VulkanglTFModel::Vertex, uv)},
+		{3, 0, VK_FORMAT_R32G32B32_SFLOAT, offsetof(VulkanglTFModel::Vertex, color)},
+		// POI: Per-Vertex Joint indices and weights are passed to the vertex shader
+		{4, 0, VK_FORMAT_R32G32B32A32_SFLOAT, offsetof(VulkanglTFModel::Vertex, jointIndices)},
+		{5, 0, VK_FORMAT_R32G32B32A32_SFLOAT, offsetof(VulkanglTFModel::Vertex, jointWeights)},
 		};
 		VkPipelineVertexInputStateCreateInfo vertexInputStateCI = vks::initializers::pipelineVertexInputStateCreateInfo();
 		vertexInputStateCI.vertexBindingDescriptionCount = static_cast<uint32_t>(vertexInputBindings.size());
@@ -738,6 +1378,11 @@ public:
 		if (camera.updated) {
 			updateUniformBuffers();
 		}
+		// POI: Advance animation
+		if (!paused)
+		{
+			glTFModel.updateAnimation(frameTimer);
+		}
 	}
 
 	virtual void viewChanged()
